diff --git a/CMakeLists.txt b/CMakeLists.txt
index bf177538a..d511a621b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,6 +33,14 @@ endif()
 # Set the project name.
 project(velox)
 
+# Halo: Inject jemalloc headers for macOS builds to avoid global pollution in parent project
+if(APPLE AND DEFINED THIRDPARTY_INSTALL_DIR AND EXISTS "${THIRDPARTY_INSTALL_DIR}/jemalloc/include/jemalloc/jemalloc.h")
+  message(STATUS "[Velox] Injecting jemalloc headers for macOS")
+  add_compile_options("SHELL:-include ${THIRDPARTY_INSTALL_DIR}/jemalloc/include/jemalloc/jemalloc.h")
+  add_compile_options("SHELL:-include ${THIRDPARTY_INSTALL_DIR}/jemalloc/include/jemalloc_prefix_compat.h")
+  include_directories(BEFORE "${THIRDPARTY_INSTALL_DIR}/jemalloc/include")
+endif()
+
 # If we are in an active conda env disable search in system paths and add env to
 # prefix path
 if(DEFINED ENV{CONDA_PREFIX})
@@ -432,7 +440,9 @@ if(ENABLE_ALL_WARNINGS)
       KNOWN_COMPILER_SPECIFIC_WARNINGS
       "-Wno-range-loop-analysis \
          -Wno-mismatched-tags \
-         -Wno-nullability-completeness"
+         -Wno-nullability-completeness \
+         -Wno-gnu-zero-variadic-macro-arguments \
+         -Wno-gnu-statement-expression"
     )
   elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
     set(
@@ -549,7 +559,6 @@ set(
   filesystem
   program_options
   regex
-  system
   thread
 )
 
@@ -622,7 +631,7 @@ if(${VELOX_BUILD_MINIMAL_WITH_DWIO} OR ${VELOX_ENABLE_HIVE_CONNECTOR} OR VELOX_E
 endif()
 
 velox_set_source(simdjson)
-velox_resolve_dependency(simdjson 4.1.0)
+velox_resolve_dependency(simdjson 4.2.2)
 
 velox_set_source(FastFloat)
 velox_resolve_dependency(FastFloat)
@@ -717,7 +726,7 @@ if(NOT VELOX_DISABLE_GOOGLETEST)
 endif()
 
 velox_set_source(xsimd)
-velox_resolve_dependency(xsimd 10.0.0)
+velox_resolve_dependency(xsimd 14.0.0)
 
 velox_set_source(stemmer)
 velox_resolve_dependency(stemmer)
@@ -747,4 +756,24 @@ if(VELOX_ENABLE_GEO)
   velox_resolve_dependency(geos)
 endif()
 
+# Remove -Wpedantic if inherited, as it triggers warnings in Velox
+get_directory_property(opts COMPILE_OPTIONS)
+list(REMOVE_ITEM opts "-Wpedantic")
+set_directory_properties(PROPERTIES COMPILE_OPTIONS "${opts}")
+
+if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  add_compile_options(
+    -Wno-gnu-zero-variadic-macro-arguments
+    -Wno-gnu-statement-expression
+    -Wno-unused-lambda-capture
+    -Wno-compound-token-split-by-macro
+    -Wno-ignored-qualifiers
+    -Wno-unused-but-set-variable
+    -Wno-unused-function
+    -Wno-deprecated-declarations
+    -Wno-unused-private-field
+    -Wno-unused-variable
+  )
+endif()
+
 add_subdirectory(velox)
diff --git a/dwio/parquet/common/BitPacking.h b/dwio/parquet/common/BitPacking.h
new file mode 100644
index 000000000..d39bbc474
--- /dev/null
+++ b/dwio/parquet/common/BitPacking.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/bpacking.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include "arrow/util/visibility.h"
+
+#include <stdint.h>
+
+namespace arrow::internal {
+
+ARROW_EXPORT
+int unpack32(const uint32_t* in, uint32_t* out, int batch_size, int num_bits);
+ARROW_EXPORT
+int unpack64(const uint8_t* in, uint64_t* out, int batch_size, int num_bits);
+
+} // namespace arrow::internal
diff --git a/velox/common/base/Fs.cpp b/velox/common/base/Fs.cpp
index bbea7b778..2821a2ea0 100644
--- a/velox/common/base/Fs.cpp
+++ b/velox/common/base/Fs.cpp
@@ -18,6 +18,7 @@
 
 #include <fmt/format.h>
 #include <glog/logging.h>
+#include <unistd.h>
 
 namespace facebook::velox::common {
 
diff --git a/velox/common/base/SimdUtil-inl.h b/velox/common/base/SimdUtil-inl.h
index 937c86d9f..b1e253f34 100644
--- a/velox/common/base/SimdUtil-inl.h
+++ b/velox/common/base/SimdUtil-inl.h
@@ -99,7 +99,8 @@ struct BitMask<T, A, 1> {
   }
 #endif
 
-  static int toBitMask(xsimd::batch_bool<T, A> mask, const xsimd::generic&) {
+  template <typename Arch>
+  static int toBitMask(xsimd::batch_bool<T, A> mask, const Arch&) {
     return genericToBitMask(mask);
   }
 };
@@ -125,7 +126,8 @@ struct BitMask<T, A, 2> {
   }
 #endif
 
-  static int toBitMask(xsimd::batch_bool<T, A> mask, const xsimd::generic&) {
+  template <typename Arch>
+  static int toBitMask(xsimd::batch_bool<T, A> mask, const Arch&) {
     return genericToBitMask(mask);
   }
 };
@@ -146,7 +148,8 @@ struct BitMask<T, A, 4> {
   }
 #endif
 
-  static int toBitMask(xsimd::batch_bool<T, A> mask, const xsimd::generic&) {
+  template <typename Arch>
+  static int toBitMask(xsimd::batch_bool<T, A> mask, const Arch&) {
     return genericToBitMask(mask);
   }
 
@@ -173,7 +176,8 @@ struct BitMask<T, A, 8> {
   }
 #endif
 
-  static int toBitMask(xsimd::batch_bool<T, A> mask, const xsimd::generic&) {
+  template <typename Arch>
+  static int toBitMask(xsimd::batch_bool<T, A> mask, const Arch&) {
     return genericToBitMask(mask);
   }
 
@@ -516,7 +520,8 @@ template <typename T, typename A>
 struct Gather<T, int32_t, A, 4> {
   using VIndexType = xsimd::batch<int32_t, A>;
 
-  static VIndexType loadIndices(const int32_t* indices, const xsimd::generic&) {
+  template <typename Arch>
+  static VIndexType loadIndices(const int32_t* indices, const Arch&) {
     return xsimd::load_unaligned<A>(indices);
   }
 
@@ -526,9 +531,9 @@ struct Gather<T, int32_t, A, 4> {
     return apply<kScale>(base, loadIndices(indices, arch), arch);
   }
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A>
-  apply(const T* base, const int32_t* indices, const xsimd::generic&) {
+  apply(const T* base, const int32_t* indices, const Arch&) {
     return genericGather<T, A, kScale>(base, indices);
   }
 
@@ -542,9 +547,9 @@ struct Gather<T, int32_t, A, 4> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A>
-  apply(const T* base, VIndexType vindex, const xsimd::generic&) {
+  apply(const T* base, VIndexType vindex, const Arch&) {
     alignas(A::alignment()) int32_t indices[vindex.size];
     vindex.store_aligned(indices);
     return genericGather<T, A, kScale>(base, indices);
@@ -572,13 +577,13 @@ struct Gather<T, int32_t, A, 4> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A> maskApply(
       xsimd::batch<T, A> src,
       xsimd::batch_bool<T, A> mask,
       const T* base,
       const int32_t* indices,
-      const xsimd::generic&) {
+      const Arch&) {
     return genericMaskGather<T, A, kScale>(src, mask, base, indices);
   }
 
@@ -600,13 +605,13 @@ struct Gather<T, int32_t, A, 4> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A> maskApply(
       xsimd::batch<T, A> src,
       xsimd::batch_bool<T, A> mask,
       const T* base,
       VIndexType vindex,
-      const xsimd::generic&) {
+      const Arch&) {
     alignas(A::alignment()) int32_t indices[vindex.size];
     vindex.store_aligned(indices);
     return genericMaskGather<T, A, kScale>(src, mask, base, indices);
@@ -659,9 +664,9 @@ struct Gather<T, int32_t, A, 8> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A>
-  apply(const T* base, const int32_t* indices, const xsimd::generic&) {
+  apply(const T* base, const int32_t* indices, const Arch&) {
     return genericGather<T, A, kScale>(base, indices);
   }
 
@@ -705,13 +710,13 @@ struct Gather<T, int32_t, A, 8> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A> maskApply(
       xsimd::batch<T, A> src,
       xsimd::batch_bool<T, A> mask,
       const T* base,
       const int32_t* indices,
-      const xsimd::generic&) {
+      const Arch&) {
     return genericMaskGather<T, A, kScale>(src, mask, base, indices);
   }
 
@@ -792,7 +797,8 @@ template <typename T, typename A>
 struct Gather<T, int64_t, A, 8> {
   using VIndexType = xsimd::batch<int64_t, A>;
 
-  static VIndexType loadIndices(const int64_t* indices, const xsimd::generic&) {
+  template <typename Arch>
+  static VIndexType loadIndices(const int64_t* indices, const Arch&) {
     return xsimd::load_unaligned<A>(indices);
   }
 
@@ -814,9 +820,9 @@ struct Gather<T, int64_t, A, 8> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A>
-  apply(const T* base, const int64_t* indices, const xsimd::generic&) {
+  apply(const T* base, const int64_t* indices, const Arch&) {
     return genericGather<T, A, kScale>(base, indices);
   }
 
@@ -860,13 +866,13 @@ struct Gather<T, int64_t, A, 8> {
   }
 #endif
 
-  template <int kScale>
+  template <int kScale, typename Arch>
   static xsimd::batch<T, A> maskApply(
       xsimd::batch<T, A> src,
       xsimd::batch_bool<T, A> mask,
       const T* base,
       VIndexType vindex,
-      const xsimd::generic&) {
+      const Arch&) {
     alignas(A::alignment()) int64_t indices[vindex.size];
     vindex.store_aligned(indices);
     return genericMaskGather<T, A, kScale>(src, mask, base, indices);
@@ -875,11 +881,11 @@ struct Gather<T, int64_t, A, 8> {
 
 // Concatenates the low 16 bits of each lane in 'x' and 'y' and
 // returns the result as 16x16 bits.
-template <typename A>
+template <typename A, typename Arch>
 xsimd::batch<int16_t, A> pack32(
     xsimd::batch<int32_t, A> x,
     xsimd::batch<int32_t, A> y,
-    const xsimd::generic&);
+    const Arch&);
 
 #if XSIMD_WITH_SSE4_1
 template <typename A>
@@ -901,15 +907,15 @@ xsimd::batch<int16_t, A> pack32(
 }
 #endif
 
-template <typename A>
+template <typename A, typename Arch>
 xsimd::batch<int16_t, A> pack32(
     xsimd::batch<int32_t, A> x,
     xsimd::batch<int32_t, A> y,
-    const xsimd::generic&) {
+    const Arch&) {
   constexpr std::size_t size = xsimd::batch<int32_t, A>::size;
-  alignas(A) int32_t xArr[size];
-  alignas(A) int32_t yArr[size];
-  alignas(A) int16_t resultArr[2 * size];
+  alignas(A::alignment()) int32_t xArr[size];
+  alignas(A::alignment()) int32_t yArr[size];
+  alignas(A::alignment()) int16_t resultArr[2 * size];
 
   x.store_unaligned(xArr);
   y.store_unaligned(yArr);
@@ -981,17 +987,19 @@ struct Permute;
 
 template <typename T, typename A>
 struct Permute<T, A, 4> {
+  template <typename Arch>
   static xsimd::batch<T, A> apply(
       xsimd::batch<T, A> data,
       xsimd::batch<int32_t, A> idx,
-      const xsimd::generic&) {
+      const Arch&) {
     return genericPermute(data, idx);
   }
 
+  template <typename Arch>
   static HalfBatch<T, A> apply(
       HalfBatch<T, A> data,
       HalfBatch<int32_t, A> idx,
-      const xsimd::generic&) {
+      const Arch&) {
     return genericPermute(data, idx);
   }
 
@@ -1046,12 +1054,12 @@ xsimd::batch<int16_t, A> gather(
 
 namespace detail {
 
-template <typename A>
+template <typename A, typename Arch>
 uint8_t gather8BitsImpl(
     const void* bits,
     xsimd::batch<int32_t, A> vindex,
     int32_t numIndices,
-    const xsimd::generic&) {
+    const Arch&) {
   alignas(A::alignment()) int32_t indices[vindex.size];
   vindex.store_aligned(indices);
   auto base = reinterpret_cast<const char*>(bits);
@@ -1111,8 +1119,9 @@ xsimd::batch<T, A> genericMaskLoad(
 
 template <typename T, typename A>
 struct MaskLoad<T, A, 4> {
+  template <typename Arch>
   static xsimd::batch<T, A>
-  apply(const T* addr, xsimd::batch_bool<T, A> mask, const xsimd::generic&) {
+  apply(const T* addr, xsimd::batch_bool<T, A> mask, const Arch&) {
     return genericMaskLoad(addr, mask);
   }
 
@@ -1126,8 +1135,9 @@ struct MaskLoad<T, A, 4> {
 
 template <typename T, typename A>
 struct MaskLoad<T, A, 8> {
+  template <typename Arch>
   static xsimd::batch<T, A>
-  apply(const T* addr, xsimd::batch_bool<T, A> mask, const xsimd::generic&) {
+  apply(const T* addr, xsimd::batch_bool<T, A> mask, const Arch&) {
     return genericMaskLoad(addr, mask);
   }
 
@@ -1164,10 +1174,10 @@ struct GetHalf<int64_t, int32_t, A> {
   }
 #endif
 
-  template <bool kSecond>
+  template <bool kSecond, typename Arch>
   static xsimd::batch<int64_t, A> apply(
       xsimd::batch<int32_t, A> data,
-      const xsimd::generic&) {
+      const Arch&) {
     constexpr std::size_t input_size = xsimd::batch<int32_t, A>::size;
     constexpr std::size_t half_size = input_size / 2;
 
@@ -1235,10 +1245,10 @@ struct GetHalf<uint64_t, int32_t, A> {
   }
 #endif
 
-  template <bool kSecond>
+  template <bool kSecond, typename Arch>
   static xsimd::batch<uint64_t, A> apply(
       xsimd::batch<int32_t, A> data,
-      const xsimd::generic&) {
+      const Arch&) {
     constexpr std::size_t input_size = xsimd::batch<int32_t, A>::size;
     constexpr std::size_t half_size = input_size / 2;
     std::array<int32_t, input_size> input_buffer;
@@ -1276,8 +1286,9 @@ filterHalf(xsimd::batch<int16_t, A> data, int mask, const xsimd::avx2&) {
 
 template <typename T, typename A>
 struct Filter<T, A, 2> {
+  template <typename Arch>
   static xsimd::batch<T, A>
-  apply(xsimd::batch<T, A> data, int mask, const xsimd::generic&) {
+  apply(xsimd::batch<T, A> data, int mask, const Arch&) {
     return genericPermute(data, byteSetBits[mask]);
   }
 
@@ -1327,8 +1338,9 @@ struct Filter<T, A, 4> {
 
 template <typename T, typename A>
 struct Filter<T, A, 8> {
+  template <typename Arch>
   static xsimd::batch<T, A>
-  apply(xsimd::batch<T, A> data, int mask, const xsimd::generic&) {
+  apply(xsimd::batch<T, A> data, int mask, const Arch&) {
     return genericPermute(data, byteSetBits[mask]);
   }
 
diff --git a/velox/common/caching/AsyncDataCache.cpp b/velox/common/caching/AsyncDataCache.cpp
index b54b4fa69..d7f01d4e9 100644
--- a/velox/common/caching/AsyncDataCache.cpp
+++ b/velox/common/caching/AsyncDataCache.cpp
@@ -674,6 +674,15 @@ AsyncDataCache::AsyncDataCache(
     std::unique_ptr<SsdCache> ssdCache)
     : AsyncDataCache({}, allocator, std::move(ssdCache)) {}
 
+AsyncDataCache::AsyncDataCache(
+    const Options& options,
+    memory::MemoryAllocator* allocator)
+    : AsyncDataCache(options, allocator, nullptr) {}
+
+AsyncDataCache::AsyncDataCache(
+    memory::MemoryAllocator* allocator)
+    : AsyncDataCache({}, allocator, nullptr) {}
+
 AsyncDataCache::AsyncDataCache(
     const Options& options,
     memory::MemoryAllocator* allocator,
@@ -700,6 +709,13 @@ std::shared_ptr<AsyncDataCache> AsyncDataCache::create(
   return cache;
 }
 
+// static
+std::shared_ptr<AsyncDataCache> AsyncDataCache::create(
+    memory::MemoryAllocator* allocator,
+    const AsyncDataCache::Options& options) {
+  return create(allocator, nullptr, options);
+}
+
 // static
 AsyncDataCache* AsyncDataCache::getInstance() {
   return *getInstancePtr();
diff --git a/velox/common/caching/AsyncDataCache.h b/velox/common/caching/AsyncDataCache.h
index 0baf904de..a0eacb52f 100644
--- a/velox/common/caching/AsyncDataCache.h
+++ b/velox/common/caching/AsyncDataCache.h
@@ -734,17 +734,28 @@ class AsyncDataCache : public memory::Cache {
   AsyncDataCache(
       const Options& options,
       memory::MemoryAllocator* allocator,
-      std::unique_ptr<SsdCache> ssdCache = nullptr);
+      std::unique_ptr<SsdCache> ssdCache);
+
+  AsyncDataCache(
+      const Options& options,
+      memory::MemoryAllocator* allocator);
 
   AsyncDataCache(
       memory::MemoryAllocator* allocator,
-      std::unique_ptr<SsdCache> ssdCache = nullptr);
+      std::unique_ptr<SsdCache> ssdCache);
+
+  AsyncDataCache(
+      memory::MemoryAllocator* allocator);
 
   ~AsyncDataCache() override;
 
   static std::shared_ptr<AsyncDataCache> create(
       memory::MemoryAllocator* allocator,
-      std::unique_ptr<SsdCache> ssdCache = nullptr,
+      std::unique_ptr<SsdCache> ssdCache,
+      const AsyncDataCache::Options& = {});
+
+  static std::shared_ptr<AsyncDataCache> create(
+      memory::MemoryAllocator* allocator,
       const AsyncDataCache::Options& = {});
 
   static AsyncDataCache* getInstance();
diff --git a/velox/common/process/ThreadDebugInfo.cpp b/velox/common/process/ThreadDebugInfo.cpp
index ae681a2dc..35ebaf485 100644
--- a/velox/common/process/ThreadDebugInfo.cpp
+++ b/velox/common/process/ThreadDebugInfo.cpp
@@ -18,6 +18,7 @@
 
 #include <folly/experimental/symbolizer/SignalHandler.h>
 #include <glog/logging.h>
+#include <unistd.h>
 
 namespace facebook::velox::process {
 thread_local const ThreadDebugInfo* threadDebugInfo = nullptr;
diff --git a/velox/dwio/common/CacheInputStream.cpp.rej b/velox/dwio/common/CacheInputStream.cpp.rej
new file mode 100644
index 000000000..be04b5bd8
--- /dev/null
+++ b/velox/dwio/common/CacheInputStream.cpp.rej
@@ -0,0 +1,12 @@
+diff a/velox/dwio/common/CacheInputStream.cpp b/velox/dwio/common/CacheInputStream.cpp	(rejected hunks)
+@@ -142,8 +142,8 @@ bool CacheInputStream::SkipInt64(int64_t count) {
+   return false;
+ }
+ 
+-google::protobuf::int64 CacheInputStream::ByteCount() const {
+-  return static_cast<google::protobuf::int64>(position_);
++int64_t CacheInputStream::ByteCount() const {
++  return static_cast<int64_t>(position_);
+ }
+ 
+ void CacheInputStream::seekToPosition(PositionProvider& seekPosition) {
diff --git a/velox/dwio/common/CacheInputStream.h.rej b/velox/dwio/common/CacheInputStream.h.rej
new file mode 100644
index 000000000..6ab9fd83e
--- /dev/null
+++ b/velox/dwio/common/CacheInputStream.h.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/common/CacheInputStream.h b/velox/dwio/common/CacheInputStream.h	(rejected hunks)
+@@ -51,7 +51,7 @@ class CacheInputStream : public SeekableInputStream {
+   bool Next(const void** data, int* size) override;
+   void BackUp(int count) override;
+   bool SkipInt64(int64_t count) override;
+-  google::protobuf::int64 ByteCount() const override;
++  int64_t ByteCount() const override;
+   void seekToPosition(PositionProvider& position) override;
+   std::string getName() const override;
+   size_t positionSize() const override;
diff --git a/velox/dwio/common/ColumnVisitors.h b/velox/dwio/common/ColumnVisitors.h
index ed29de618..6377a9972 100644
--- a/velox/dwio/common/ColumnVisitors.h
+++ b/velox/dwio/common/ColumnVisitors.h
@@ -576,9 +576,10 @@ struct LoadIndices<float, A> {
 
 template <typename A>
 struct LoadIndices<int16_t, A> {
+  template <typename Arch>
   static xsimd::batch<int32_t, A> apply(
       const int16_t* values,
-      const xsimd::generic&) {
+      const Arch&) {
     constexpr int N = xsimd::batch<int32_t, A>::size;
     alignas(A::alignment()) int32_t tmp[N];
     for (int i = 0; i < N; ++i) {
diff --git a/velox/dwio/common/DirectInputStream.cpp.rej b/velox/dwio/common/DirectInputStream.cpp.rej
new file mode 100644
index 000000000..1f870fe77
--- /dev/null
+++ b/velox/dwio/common/DirectInputStream.cpp.rej
@@ -0,0 +1,12 @@
+diff a/velox/dwio/common/DirectInputStream.cpp b/velox/dwio/common/DirectInputStream.cpp	(rejected hunks)
+@@ -91,8 +91,8 @@ bool DirectInputStream::SkipInt64(int64_t count) {
+   return false;
+ }
+ 
+-google::protobuf::int64 DirectInputStream::ByteCount() const {
+-  return static_cast<google::protobuf::int64>(offsetInRegion_);
++int64_t DirectInputStream::ByteCount() const {
++  return static_cast<int64_t>(offsetInRegion_);
+ }
+ 
+ void DirectInputStream::seekToPosition(PositionProvider& seekPosition) {
diff --git a/velox/dwio/common/DirectInputStream.h.rej b/velox/dwio/common/DirectInputStream.h.rej
new file mode 100644
index 000000000..04ef8ffe1
--- /dev/null
+++ b/velox/dwio/common/DirectInputStream.h.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/common/DirectInputStream.h b/velox/dwio/common/DirectInputStream.h	(rejected hunks)
+@@ -44,7 +44,7 @@ class DirectInputStream : public SeekableInputStream {
+   bool Next(const void** data, int* size) override;
+   void BackUp(int count) override;
+   bool SkipInt64(int64_t count) override;
+-  google::protobuf::int64 ByteCount() const override;
++  int64_t ByteCount() const override;
+ 
+   void seekToPosition(PositionProvider& position) override;
+   std::string getName() const override;
diff --git a/velox/dwio/common/OutputStream.h.rej b/velox/dwio/common/OutputStream.h.rej
new file mode 100644
index 000000000..bc40d4977
--- /dev/null
+++ b/velox/dwio/common/OutputStream.h.rej
@@ -0,0 +1,12 @@
+diff a/velox/dwio/common/OutputStream.h b/velox/dwio/common/OutputStream.h	(rejected hunks)
+@@ -47,8 +47,8 @@ class BufferedOutputStream : public google::protobuf::io::ZeroCopyOutputStream {
+ 
+   void BackUp(int32_t count) override;
+ 
+-  google::protobuf::int64 ByteCount() const override {
+-    return static_cast<google::protobuf::int64>(size());
++  int64_t ByteCount() const override {
++    return static_cast<int64_t>(size());
+   }
+ 
+   bool WriteAliasedRaw(const void* /* unused */, int32_t /* unused */)
diff --git a/velox/dwio/common/SeekableInputStream.cpp.rej b/velox/dwio/common/SeekableInputStream.cpp.rej
new file mode 100644
index 000000000..ebca3cfc5
--- /dev/null
+++ b/velox/dwio/common/SeekableInputStream.cpp.rej
@@ -0,0 +1,42 @@
+diff a/velox/dwio/common/SeekableInputStream.cpp b/velox/dwio/common/SeekableInputStream.cpp	(rejected hunks)
+@@ -152,19 +152,20 @@ void SeekableArrayInputStream::BackUp(int32_t count) {
+ bool SeekableArrayInputStream::SkipInt64(int64_t count) {
+   loadIfAvailable();
+ 
+-  if (count >= 0) {
+-    const uint64_t unsignedCount = static_cast<uint64_t>(count);
+-    if (unsignedCount + position_ <= length_) {
+-      position_ += unsignedCount;
+-      return true;
+-    }
++  if (count < 0) {
++    return false;
++  }
++  const uint64_t unsignedCount = static_cast<uint64_t>(count);
++  if (unsignedCount > length_ - position_) {
+     position_ = length_;
++    return false;
+   }
+-  return false;
++  position_ += unsignedCount;
++  return true;
+ }
+ 
+-google::protobuf::int64 SeekableArrayInputStream::ByteCount() const {
+-  return static_cast<google::protobuf::int64>(position_);
++int64_t SeekableArrayInputStream::ByteCount() const {
++  return static_cast<int64_t>(position_);
+ }
+ 
+ void SeekableArrayInputStream::seekToPosition(PositionProvider& position) {
+@@ -241,8 +242,8 @@ bool SeekableFileInputStream::SkipInt64(int64_t signedCount) {
+   return position_ < length_;
+ }
+ 
+-google::protobuf::int64 SeekableFileInputStream::ByteCount() const {
+-  return static_cast<google::protobuf::int64>(position_);
++int64_t SeekableFileInputStream::ByteCount() const {
++  return static_cast<int64_t>(position_);
+ }
+ 
+ void SeekableFileInputStream::seekToPosition(PositionProvider& location) {
diff --git a/velox/dwio/common/SeekableInputStream.h.rej b/velox/dwio/common/SeekableInputStream.h.rej
new file mode 100644
index 000000000..637bc05df
--- /dev/null
+++ b/velox/dwio/common/SeekableInputStream.h.rej
@@ -0,0 +1,19 @@
+diff a/velox/dwio/common/SeekableInputStream.h b/velox/dwio/common/SeekableInputStream.h	(rejected hunks)
+@@ -79,7 +79,7 @@ class SeekableArrayInputStream : public SeekableInputStream {
+   virtual bool Next(const void** data, int32_t* size) override;
+   virtual void BackUp(int32_t count) override;
+   virtual bool SkipInt64(int64_t count) override;
+-  virtual google::protobuf::int64 ByteCount() const override;
++  virtual int64_t ByteCount() const override;
+   virtual void seekToPosition(PositionProvider& position) override;
+   virtual std::string getName() const override;
+   virtual size_t positionSize() const override;
+@@ -120,7 +120,7 @@ class SeekableFileInputStream : public SeekableInputStream {
+   virtual bool Next(const void** data, int32_t* size) override;
+   virtual void BackUp(int32_t count) override;
+   virtual bool SkipInt64(int64_t count) override;
+-  virtual google::protobuf::int64 ByteCount() const override;
++  virtual int64_t ByteCount() const override;
+   virtual void seekToPosition(PositionProvider& position) override;
+   virtual std::string getName() const override;
+   virtual size_t positionSize() const override;
diff --git a/velox/dwio/common/compression/PagedInputStream.h.rej b/velox/dwio/common/compression/PagedInputStream.h.rej
new file mode 100644
index 000000000..f6358bb5d
--- /dev/null
+++ b/velox/dwio/common/compression/PagedInputStream.h.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/common/compression/PagedInputStream.h b/velox/dwio/common/compression/PagedInputStream.h	(rejected hunks)
+@@ -56,7 +56,7 @@ class PagedInputStream : public dwio::common::SeekableInputStream {
+   // NOTE: This always returns true.
+   bool SkipInt64(int64_t count) override;
+ 
+-  google::protobuf::int64 ByteCount() const override {
++  int64_t ByteCount() const override {
+     return bytesReturned_ + pendingSkip_;
+   }
+ 
diff --git a/velox/dwio/dwrf/test/TestDecompression.cpp.rej b/velox/dwio/dwrf/test/TestDecompression.cpp.rej
new file mode 100644
index 000000000..19e487f24
--- /dev/null
+++ b/velox/dwio/dwrf/test/TestDecompression.cpp.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/dwrf/test/TestDecompression.cpp b/velox/dwio/dwrf/test/TestDecompression.cpp	(rejected hunks)
+@@ -1065,7 +1065,7 @@ class TestingSeekableInputStream : public SeekableInputStream {
+     return true;
+   }
+ 
+-  google::protobuf::int64 ByteCount() const override {
++  int64_t ByteCount() const override {
+     return position_;
+   }
+ 
diff --git a/velox/dwio/dwrf/writer/IndexBuilder.h.rej b/velox/dwio/dwrf/writer/IndexBuilder.h.rej
new file mode 100644
index 000000000..1d1b61756
--- /dev/null
+++ b/velox/dwio/dwrf/writer/IndexBuilder.h.rej
@@ -0,0 +1,13 @@
+diff a/velox/dwio/dwrf/writer/IndexBuilder.h b/velox/dwio/dwrf/writer/IndexBuilder.h	(rejected hunks)
+@@ -41,9 +41,9 @@ class IndexBuilder : public PositionRecorder {
+       : out_{std::move(out)},
+         arena_(std::make_unique<google::protobuf::Arena>()) {
+     auto rowIndex =
+-        google::protobuf::Arena::CreateMessage<proto::RowIndex>(arena_.get());
++        google::protobuf::Arena::Create<proto::RowIndex>(arena_.get());
+     auto rowIndexEntry =
+-        google::protobuf::Arena::CreateMessage<proto::RowIndexEntry>(
++        google::protobuf::Arena::Create<proto::RowIndexEntry>(
+             arena_.get());
+ 
+     index_ = std::make_unique<RowIndexWriteWrapper>(rowIndex);
diff --git a/velox/dwio/dwrf/writer/LayoutPlanner.cpp.rej b/velox/dwio/dwrf/writer/LayoutPlanner.cpp.rej
new file mode 100644
index 000000000..e7a04ff8f
--- /dev/null
+++ b/velox/dwio/dwrf/writer/LayoutPlanner.cpp.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/dwrf/writer/LayoutPlanner.cpp b/velox/dwio/dwrf/writer/LayoutPlanner.cpp	(rejected hunks)
+@@ -129,7 +129,7 @@ EncodingManager::EncodingManager(
+       arena_{std::make_unique<google::protobuf::Arena>()} {
+   initEncryptionGroups();
+   auto dwrfStripeFooter =
+-      google::protobuf::Arena::CreateMessage<proto::StripeFooter>(arena_.get());
++      google::protobuf::Arena::Create<proto::StripeFooter>(arena_.get());
+   footer_ = std::make_unique<StripeFooterWriteWrapper>(dwrfStripeFooter);
+ }
+ 
diff --git a/velox/dwio/dwrf/writer/StatisticsBuilder.cpp.rej b/velox/dwio/dwrf/writer/StatisticsBuilder.cpp.rej
new file mode 100644
index 000000000..08f51e0c1
--- /dev/null
+++ b/velox/dwio/dwrf/writer/StatisticsBuilder.cpp.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/dwrf/writer/StatisticsBuilder.cpp b/velox/dwio/dwrf/writer/StatisticsBuilder.cpp	(rejected hunks)
+@@ -119,7 +119,7 @@ void StatisticsBuilder::toProto(ColumnStatisticsWriteWrapper& stats) const {
+ std::unique_ptr<dwio::common::ColumnStatistics> StatisticsBuilder::build()
+     const {
+   auto columnStatistics =
+-      google::protobuf::Arena::CreateMessage<proto::ColumnStatistics>(
++      google::protobuf::Arena::Create<proto::ColumnStatistics>(
+           arena_.get());
+   auto stats = ColumnStatisticsWriteWrapper(columnStatistics);
+   toProto(stats);
diff --git a/velox/dwio/dwrf/writer/WriterBase.cpp.rej b/velox/dwio/dwrf/writer/WriterBase.cpp.rej
new file mode 100644
index 000000000..73888d6da
--- /dev/null
+++ b/velox/dwio/dwrf/writer/WriterBase.cpp.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/dwrf/writer/WriterBase.cpp b/velox/dwio/dwrf/writer/WriterBase.cpp	(rejected hunks)
+@@ -59,7 +59,7 @@ void WriterBase::writeFooter(const Type& type) {
+   // write postscript
+   pos = writerSink_->size();
+   auto dwrfPostScript =
+-      google::protobuf::Arena::CreateMessage<proto::PostScript>(arena_.get());
++      google::protobuf::Arena::Create<proto::PostScript>(arena_.get());
+   std::unique_ptr<PostScriptWriteWrapper> ps =
+       std::make_unique<PostScriptWriteWrapper>(dwrfPostScript);
+   ps->setWriterVersion(writerVersion);
diff --git a/velox/dwio/dwrf/writer/WriterBase.h.rej b/velox/dwio/dwrf/writer/WriterBase.h.rej
new file mode 100644
index 000000000..046adb07b
--- /dev/null
+++ b/velox/dwio/dwrf/writer/WriterBase.h.rej
@@ -0,0 +1,10 @@
+diff a/velox/dwio/dwrf/writer/WriterBase.h b/velox/dwio/dwrf/writer/WriterBase.h	(rejected hunks)
+@@ -90,7 +90,7 @@ class WriterBase {
+         context_->getMemoryPool(MemoryUsageCategory::OUTPUT_STREAM),
+         context_->getConfigs());
+     auto dwrfFooter_ =
+-        google::protobuf::Arena::CreateMessage<proto::Footer>(arena_.get());
++        google::protobuf::Arena::Create<proto::Footer>(arena_.get());
+     footer_ = std::make_unique<FooterWriteWrapper>(dwrfFooter_);
+   }
+ 
diff --git a/velox/dwio/parquet/common/BitPacking.h b/velox/dwio/parquet/common/BitPacking.h
new file mode 100644
index 000000000..8eef9d15a
--- /dev/null
+++ b/velox/dwio/parquet/common/BitPacking.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/bpacking.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include "arrow/util/visibility.h"
+
+#include <stdint.h>
+
+namespace arrow::internal {
+
+ARROW_EXPORT
+int unpack32(const uint32_t* in, uint32_t* out, int batch_size, int num_bits);
+ARROW_EXPORT
+int unpack64(const uint8_t* in, uint64_t* out, int batch_size, int num_bits);
+
+} // namespace arrow::internal
diff --git a/velox/dwio/parquet/common/BitStreamUtilsInternal.h b/velox/dwio/parquet/common/BitStreamUtilsInternal.h
index a49cea663..001e3b3a0 100644
--- a/velox/dwio/parquet/common/BitStreamUtilsInternal.h
+++ b/velox/dwio/parquet/common/BitStreamUtilsInternal.h
@@ -27,7 +27,8 @@
 #include "velox/common/base/Exceptions.h"
 
 #include "arrow/util/bit_util.h"
-#include "arrow/util/bpacking.h"
+#include "arrow/util/endian.h"
+#include "velox/dwio/parquet/common/BitPacking.h"
 
 namespace facebook::velox::parquet {
 
diff --git a/velox/dwio/parquet/common/Spaced.h b/velox/dwio/parquet/common/Spaced.h
new file mode 100644
index 000000000..3cc4340d2
--- /dev/null
+++ b/velox/dwio/parquet/common/Spaced.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/spaced.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include <cassert>
+#include <cstdint>
+#include <cstring>
+
+#include <arrow/util/bit_run_reader.h>
+
+namespace facebook::velox::parquet::arrow::util::internal {
+
+/// \brief Compress the buffer to spaced, excluding the null entries.
+///
+/// \param[in] src the source buffer
+/// \param[in] num_values the size of source buffer
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \param[out] output the output buffer spaced
+/// \return The size of spaced buffer.
+template <typename T>
+inline int SpacedCompress(
+    const T* src,
+    int num_values,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset,
+    T* output) {
+  int num_valid_values = 0;
+
+  ::arrow::internal::SetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    std::memcpy(
+        output + num_valid_values, src + run.position, run.length * sizeof(T));
+    num_valid_values += static_cast<int32_t>(run.length);
+  }
+
+  return num_valid_values;
+}
+
+/// \brief Relocate values in buffer into positions of non-null values as
+/// indicated by a validity bitmap.
+///
+/// \param[in, out] buffer the in-place buffer
+/// \param[in] num_values total size of buffer including null slots
+/// \param[in] null_count number of null slots
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \return The number of values expanded, including nulls.
+template <typename T>
+inline int SpacedExpand(
+    T* buffer,
+    int num_values,
+    int null_count,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset) {
+  // Point to end as we add the spacing from the back.
+  int idx_decode = num_values - null_count;
+
+  // Depending on the number of nulls, some of the value slots in buffer may
+  // be uninitialized, and this will cause valgrind warnings / potentially UB
+  std::memset(
+      static_cast<void*>(buffer + idx_decode), 0, null_count * sizeof(T));
+  if (idx_decode == 0) {
+    // All nulls, nothing more to do
+    return num_values;
+  }
+
+  ::arrow::internal::ReverseSetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    idx_decode -= static_cast<int32_t>(run.length);
+    assert(idx_decode >= 0);
+    std::memmove(
+        buffer + run.position, buffer + idx_decode, run.length * sizeof(T));
+  }
+
+  // Otherwise caller gave an incorrect null_count
+  assert(idx_decode == 0);
+  return num_values;
+}
+
+} // namespace facebook::velox::parquet::arrow::util::internal
diff --git a/velox/dwio/parquet/writer/arrow/Encoding.cpp b/velox/dwio/parquet/writer/arrow/Encoding.cpp
index f4a5990e5..77829fe68 100644
--- a/velox/dwio/parquet/writer/arrow/Encoding.cpp
+++ b/velox/dwio/parquet/writer/arrow/Encoding.cpp
@@ -164,7 +164,7 @@ class PlainEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -379,7 +379,7 @@ class PlainEncoder<BooleanType> : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -997,7 +997,7 @@ void ByteStreamSplitEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -2744,7 +2744,7 @@ void DeltaBitPackEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3116,7 +3116,7 @@ void DeltaLengthByteArrayEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3353,7 +3353,7 @@ class RleBooleanEncoder final : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -3565,7 +3565,7 @@ class DeltaByteArrayEncoder : public EncoderImpl,
         PARQUET_THROW_NOT_OK(buffer_->Resize(num_values * sizeof(T), false));
       }
       T* data = reinterpret_cast<T*>(buffer_->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
diff --git a/velox/dwio/parquet/writer/arrow/Encoding.h b/velox/dwio/parquet/writer/arrow/Encoding.h
index b57ee2b68..0840e9e88 100644
--- a/velox/dwio/parquet/writer/arrow/Encoding.h
+++ b/velox/dwio/parquet/writer/arrow/Encoding.h
@@ -23,7 +23,7 @@
 #include <memory>
 #include <vector>
 
-#include "arrow/util/spaced.h"
+#include "velox/dwio/parquet/writer/arrow/util/Spaced.h"
 
 #include "velox/dwio/parquet/writer/arrow/Exception.h"
 #include "velox/dwio/parquet/writer/arrow/Platform.h"
@@ -307,7 +307,7 @@ class TypedDecoder : virtual public Decoder {
             "Number of values / definition_levels read did not match");
       }
 
-      return ::arrow::util::internal::SpacedExpand<T>(
+      return util::internal::SpacedExpand<T>(
           buffer, num_values, null_count, valid_bits, valid_bits_offset);
     } else {
       return Decode(buffer, num_values);
diff --git a/velox/dwio/parquet/writer/arrow/Exception.h b/velox/dwio/parquet/writer/arrow/Exception.h
index b71cfc926..6a638028e 100644
--- a/velox/dwio/parquet/writer/arrow/Exception.h
+++ b/velox/dwio/parquet/writer/arrow/Exception.h
@@ -24,7 +24,12 @@
 #include <utility>
 
 #include "arrow/type_fwd.h"
+#include "arrow/config.h"
+#if ARROW_VERSION_MAJOR >= 21
+#include "arrow/util/string_util.h"
+#else
 #include "arrow/util/string_builder.h"
+#endif
 #include "velox/dwio/parquet/writer/arrow/Platform.h"
 
 // PARQUET-1085
@@ -60,6 +65,22 @@
 
 // Arrow Status to Parquet exception
 
+#if ARROW_VERSION_MAJOR >= 21
+#define PARQUET_IGNORE_NOT_OK(s) \
+  do {                           \
+    ::arrow::Status _s = ::arrow::ToStatus(s); \
+    ARROW_UNUSED(_s);            \
+  } while (0)
+
+#define PARQUET_THROW_NOT_OK(s)                                            \
+  do {                                                                     \
+    ::arrow::Status _s = ::arrow::ToStatus(s);                             \
+    if (!_s.ok()) {                                                        \
+      throw ::facebook::velox::parquet::arrow::ParquetStatusException(     \
+          std::move(_s));                                                  \
+    }                                                                      \
+  } while (0)
+#else
 #define PARQUET_IGNORE_NOT_OK(s)                                \
   do {                                                          \
     ::arrow::Status _s = ::arrow::internal::GenericToStatus(s); \
@@ -74,6 +95,7 @@
           std::move(_s));                                              \
     }                                                                  \
   } while (0)
+#endif
 
 #define PARQUET_ASSIGN_OR_THROW_IMPL(status_name, lhs, rexpr) \
   auto status_name = (rexpr);                                 \
@@ -102,7 +124,11 @@ class ParquetException : public std::exception {
 
   template <typename... Args>
   explicit ParquetException(Args&&... args)
+#if ARROW_VERSION_MAJOR >= 21
+      : msg_(::arrow::internal::JoinToString(std::forward<Args>(args)...)) {}
+#else
       : msg_(::arrow::util::StringBuilder(std::forward<Args>(args)...)) {}
+#endif
 
   explicit ParquetException(std::string msg) : msg_(std::move(msg)) {}
 
diff --git a/velox/dwio/parquet/writer/arrow/Exception.h.rej b/velox/dwio/parquet/writer/arrow/Exception.h.rej
new file mode 100644
index 000000000..47664ac13
--- /dev/null
+++ b/velox/dwio/parquet/writer/arrow/Exception.h.rej
@@ -0,0 +1,31 @@
+diff a/velox/dwio/parquet/writer/arrow/Exception.h b/velox/dwio/parquet/writer/arrow/Exception.h	(rejected hunks)
+@@ -23,8 +23,13 @@
+ #include <string>
+ #include <utility>
+ 
++#include "arrow/config.h"
+ #include "arrow/type_fwd.h"
++#if ARROW_VERSION_MAJOR >= 21
++#include "arrow/util/string_util.h"
++#else
+ #include "arrow/util/string_builder.h"
++#endif
+ #include "velox/dwio/parquet/writer/arrow/Platform.h"
+ 
+ // PARQUET-1085
+@@ -102,7 +124,14 @@ class ParquetException : public std::exception {
+ 
+   template <typename... Args>
+   explicit ParquetException(Args&&... args)
+-      : msg_(::arrow::util::StringBuilder(std::forward<Args>(args)...)) {}
++      : msg_(
++#if ARROW_VERSION_MAJOR >= 21
++          ::arrow::internal::JoinToString(std::forward<Args>(args)...)
++#else
++          ::arrow::util::StringBuilder(std::forward<Args>(args)...)
++#endif
++      ) {
++  }
+ 
+   explicit ParquetException(std::string msg) : msg_(std::move(msg)) {}
+ 
diff --git a/velox/dwio/parquet/writer/arrow/Writer.cpp b/velox/dwio/parquet/writer/arrow/Writer.cpp
index f3a101a02..8ed8dbf4a 100644
--- a/velox/dwio/parquet/writer/arrow/Writer.cpp
+++ b/velox/dwio/parquet/writer/arrow/Writer.cpp
@@ -419,16 +419,22 @@ class FileWriterImpl : public FileWriter {
 
     if (table.num_rows() == 0) {
       // Append a row group with 0 rows
-      RETURN_NOT_OK_ELSE(WriteRowGroup(0, 0), PARQUET_IGNORE_NOT_OK(Close()));
+      auto s = WriteRowGroup(0, 0);
+      if (!s.ok()) {
+        PARQUET_IGNORE_NOT_OK(Close());
+        return s;
+      }
       return Status::OK();
     }
 
     for (int chunk = 0; chunk * chunk_size < table.num_rows(); chunk++) {
       int64_t offset = chunk * chunk_size;
-      RETURN_NOT_OK_ELSE(
-          WriteRowGroup(
-              offset, std::min(chunk_size, table.num_rows() - offset)),
-          PARQUET_IGNORE_NOT_OK(Close()));
+      auto s = WriteRowGroup(
+          offset, std::min(chunk_size, table.num_rows() - offset));
+      if (!s.ok()) {
+        PARQUET_IGNORE_NOT_OK(Close());
+        return s;
+      }
     }
     return Status::OK();
   }
diff --git a/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp b/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp
index cb9f85196..8a5e63732 100644
--- a/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp
+++ b/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp
@@ -962,7 +962,8 @@ TEST(TestColumnWriter, RepeatedListsUpdateSpacedBug) {
   std::shared_ptr<Buffer> valid_bits;
   ASSERT_OK_AND_ASSIGN(
       valid_bits,
-      ::arrow::internal::BytesToBits({1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1}));
+      ::arrow::internal::BytesToBits(
+          std::vector<uint8_t>{1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1}));
 
   // valgrind will warn about out of bounds access into def_levels_data
   typed_writer->WriteBatchSpaced(
diff --git a/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp b/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp
index 47d501aef..5bd0f6129 100644
--- a/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp
+++ b/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp
@@ -138,7 +138,7 @@ class PlainEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -359,7 +359,7 @@ class PlainEncoder<BooleanType> : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -1040,7 +1040,7 @@ void ByteStreamSplitEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -2712,7 +2712,7 @@ void DeltaBitPackEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3079,7 +3079,7 @@ void DeltaLengthByteArrayEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3316,7 +3316,7 @@ class RleBooleanEncoder final : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
diff --git a/velox/dwio/parquet/writer/arrow/util/Spaced.h b/velox/dwio/parquet/writer/arrow/util/Spaced.h
new file mode 100644
index 000000000..3cc4340d2
--- /dev/null
+++ b/velox/dwio/parquet/writer/arrow/util/Spaced.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/spaced.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include <cassert>
+#include <cstdint>
+#include <cstring>
+
+#include <arrow/util/bit_run_reader.h>
+
+namespace facebook::velox::parquet::arrow::util::internal {
+
+/// \brief Compress the buffer to spaced, excluding the null entries.
+///
+/// \param[in] src the source buffer
+/// \param[in] num_values the size of source buffer
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \param[out] output the output buffer spaced
+/// \return The size of spaced buffer.
+template <typename T>
+inline int SpacedCompress(
+    const T* src,
+    int num_values,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset,
+    T* output) {
+  int num_valid_values = 0;
+
+  ::arrow::internal::SetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    std::memcpy(
+        output + num_valid_values, src + run.position, run.length * sizeof(T));
+    num_valid_values += static_cast<int32_t>(run.length);
+  }
+
+  return num_valid_values;
+}
+
+/// \brief Relocate values in buffer into positions of non-null values as
+/// indicated by a validity bitmap.
+///
+/// \param[in, out] buffer the in-place buffer
+/// \param[in] num_values total size of buffer including null slots
+/// \param[in] null_count number of null slots
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \return The number of values expanded, including nulls.
+template <typename T>
+inline int SpacedExpand(
+    T* buffer,
+    int num_values,
+    int null_count,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset) {
+  // Point to end as we add the spacing from the back.
+  int idx_decode = num_values - null_count;
+
+  // Depending on the number of nulls, some of the value slots in buffer may
+  // be uninitialized, and this will cause valgrind warnings / potentially UB
+  std::memset(
+      static_cast<void*>(buffer + idx_decode), 0, null_count * sizeof(T));
+  if (idx_decode == 0) {
+    // All nulls, nothing more to do
+    return num_values;
+  }
+
+  ::arrow::internal::ReverseSetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    idx_decode -= static_cast<int32_t>(run.length);
+    assert(idx_decode >= 0);
+    std::memmove(
+        buffer + run.position, buffer + idx_decode, run.length * sizeof(T));
+  }
+
+  // Otherwise caller gave an incorrect null_count
+  assert(idx_decode == 0);
+  return num_values;
+}
+
+} // namespace facebook::velox::parquet::arrow::util::internal
diff --git a/velox/external/hdfs/ArrowHdfsInternal.cpp b/velox/external/hdfs/ArrowHdfsInternal.cpp
index dc22b64ce306eb7665509b099b196223e8d91116..5ecc3546c18dd090de3efeb1d30a6d6688441f1e 100644
GIT binary patch
delta 21
ccmex0k+ESC;|4zqHpieK|M2+Deimy409!8yy8r+H

delta 14
VcmZpe#Q19>;|4#A%^?<R1OP6^1<?Qi

diff --git a/velox/type/DecimalUtil.h b/velox/type/DecimalUtil.h
index 581c776f7..cd8161fa9 100644
--- a/velox/type/DecimalUtil.h
+++ b/velox/type/DecimalUtil.h
@@ -356,10 +356,46 @@ class DecimalUtil {
         *writePosition++ = '-';
         unscaledValue = -unscaledValue;
       }
-      auto [position, errorCode] = std::to_chars(
-          writePosition,
-          writePosition + maxSize,
-          unscaledValue / DecimalUtil::kPowersOfTen[scale]);
+      auto to_chars_wrapper = [&](auto v) {
+        using V = decltype(v);
+        if constexpr (sizeof(V) <= 8) {
+          return std::to_chars(writePosition, writePosition + maxSize, v);
+        } else {
+          if (v <= static_cast<V>(std::numeric_limits<uint64_t>::max())) {
+            return std::to_chars(
+                writePosition, writePosition + maxSize, static_cast<uint64_t>(v));
+          } else {
+            char buf[40];
+            char* end = buf + 40;
+            char* curr = end;
+            auto tmp = v;
+            constexpr uint64_t kChunk = 10000000000000000000ULL;
+            while (tmp > std::numeric_limits<uint64_t>::max()) {
+              uint64_t rem = static_cast<uint64_t>(tmp % kChunk);
+              tmp /= kChunk;
+              char chunkBuf[20];
+              auto res = std::to_chars(chunkBuf, chunkBuf + 20, rem);
+              int len = res.ptr - chunkBuf;
+              curr -= 19;
+              std::memset(curr, '0', 19 - len);
+              std::memcpy(curr + (19 - len), chunkBuf, len);
+            }
+            uint64_t last = static_cast<uint64_t>(tmp);
+            char chunkBuf[20];
+            auto res = std::to_chars(chunkBuf, chunkBuf + 20, last);
+            int len = res.ptr - chunkBuf;
+            curr -= len;
+            std::memcpy(curr, chunkBuf, len);
+            int totalLen = end - curr;
+            std::memcpy(writePosition, curr, totalLen);
+            writePosition += totalLen;
+            return std::to_chars_result{writePosition, std::errc()};
+          }
+        }
+      };
+
+      auto [position, errorCode] =
+          to_chars_wrapper(unscaledValue / DecimalUtil::kPowersOfTen[scale]);
       VELOX_DCHECK_EQ(
           errorCode,
           std::errc(),
@@ -375,8 +411,7 @@ class DecimalUtil {
         std::memset(writePosition, '0', numLeadingZeros);
         writePosition += numLeadingZeros;
         // Append remaining fraction digits.
-        auto result =
-            std::to_chars(writePosition, writePosition + maxSize, fraction);
+        auto result = to_chars_wrapper(fraction);
         VELOX_DCHECK_EQ(
             result.ec,
             std::errc(),
