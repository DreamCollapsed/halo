diff --git a/CMakeLists.txt b/CMakeLists.txt
index d0ceeb392..a156236f6 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,6 +33,14 @@ endif()
 # Set the project name.
 project(velox)
 
+# Halo: Inject jemalloc headers for macOS builds to avoid global pollution in parent project
+if(APPLE AND DEFINED THIRDPARTY_INSTALL_DIR AND EXISTS "${THIRDPARTY_INSTALL_DIR}/jemalloc/include/jemalloc/jemalloc.h")
+  message(STATUS "[Velox] Injecting jemalloc headers for macOS")
+  add_compile_options("SHELL:-include ${THIRDPARTY_INSTALL_DIR}/jemalloc/include/jemalloc/jemalloc.h")
+  add_compile_options("SHELL:-include ${THIRDPARTY_INSTALL_DIR}/jemalloc/include/jemalloc_prefix_compat.h")
+  include_directories(BEFORE "${THIRDPARTY_INSTALL_DIR}/jemalloc/include")
+endif()
+
 # If we are in an active conda env disable search in system paths and add env to
 # prefix path
 if(DEFINED ENV{CONDA_PREFIX})
@@ -432,7 +440,9 @@ if(ENABLE_ALL_WARNINGS)
       KNOWN_COMPILER_SPECIFIC_WARNINGS
       "-Wno-range-loop-analysis \
          -Wno-mismatched-tags \
-         -Wno-nullability-completeness"
+         -Wno-nullability-completeness \
+         -Wno-gnu-zero-variadic-macro-arguments \
+         -Wno-gnu-statement-expression"
     )
   elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
     set(
@@ -549,7 +559,6 @@ set(
   filesystem
   program_options
   regex
-  system
   thread
 )
 
@@ -619,7 +628,7 @@ if(${VELOX_BUILD_MINIMAL_WITH_DWIO} OR ${VELOX_ENABLE_HIVE_CONNECTOR} OR VELOX_E
 endif()
 
 velox_set_source(simdjson)
-velox_resolve_dependency(simdjson 4.1.0)
+velox_resolve_dependency(simdjson 4.2.2)
 
 velox_set_source(FastFloat)
 velox_resolve_dependency(FastFloat)
@@ -714,7 +723,7 @@ if(NOT VELOX_DISABLE_GOOGLETEST)
 endif()
 
 velox_set_source(xsimd)
-velox_resolve_dependency(xsimd 10.0.0)
+velox_resolve_dependency(xsimd 13.2.0)
 
 velox_set_source(stemmer)
 velox_resolve_dependency(stemmer)
@@ -744,4 +753,24 @@ if(VELOX_ENABLE_GEO)
   velox_resolve_dependency(geos)
 endif()
 
+# Remove -Wpedantic if inherited, as it triggers warnings in Velox
+get_directory_property(opts COMPILE_OPTIONS)
+list(REMOVE_ITEM opts "-Wpedantic")
+set_directory_properties(PROPERTIES COMPILE_OPTIONS "${opts}")
+
+if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  add_compile_options(
+    -Wno-gnu-zero-variadic-macro-arguments
+    -Wno-gnu-statement-expression
+    -Wno-unused-lambda-capture
+    -Wno-compound-token-split-by-macro
+    -Wno-ignored-qualifiers
+    -Wno-unused-but-set-variable
+    -Wno-unused-function
+    -Wno-deprecated-declarations
+    -Wno-unused-private-field
+    -Wno-unused-variable
+  )
+endif()
+
 add_subdirectory(velox)
diff --git a/dwio/parquet/common/BitPacking.h b/dwio/parquet/common/BitPacking.h
new file mode 100644
index 000000000..d39bbc474
--- /dev/null
+++ b/dwio/parquet/common/BitPacking.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/bpacking.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include "arrow/util/visibility.h"
+
+#include <stdint.h>
+
+namespace arrow::internal {
+
+ARROW_EXPORT
+int unpack32(const uint32_t* in, uint32_t* out, int batch_size, int num_bits);
+ARROW_EXPORT
+int unpack64(const uint8_t* in, uint64_t* out, int batch_size, int num_bits);
+
+} // namespace arrow::internal
diff --git a/velox/common/base/Fs.cpp b/velox/common/base/Fs.cpp
index bbea7b778..2821a2ea0 100644
--- a/velox/common/base/Fs.cpp
+++ b/velox/common/base/Fs.cpp
@@ -18,6 +18,7 @@
 
 #include <fmt/format.h>
 #include <glog/logging.h>
+#include <unistd.h>
 
 namespace facebook::velox::common {
 
diff --git a/velox/common/caching/AsyncDataCache.cpp b/velox/common/caching/AsyncDataCache.cpp
index bb81ddbb6..7ffdba29f 100644
--- a/velox/common/caching/AsyncDataCache.cpp
+++ b/velox/common/caching/AsyncDataCache.cpp
@@ -664,6 +664,15 @@ AsyncDataCache::AsyncDataCache(
     std::unique_ptr<SsdCache> ssdCache)
     : AsyncDataCache({}, allocator, std::move(ssdCache)) {}
 
+AsyncDataCache::AsyncDataCache(
+    const Options& options,
+    memory::MemoryAllocator* allocator)
+    : AsyncDataCache(options, allocator, nullptr) {}
+
+AsyncDataCache::AsyncDataCache(
+    memory::MemoryAllocator* allocator)
+    : AsyncDataCache({}, allocator, nullptr) {}
+
 AsyncDataCache::AsyncDataCache(
     const Options& options,
     memory::MemoryAllocator* allocator,
@@ -690,6 +699,13 @@ std::shared_ptr<AsyncDataCache> AsyncDataCache::create(
   return cache;
 }
 
+// static
+std::shared_ptr<AsyncDataCache> AsyncDataCache::create(
+    memory::MemoryAllocator* allocator,
+    const AsyncDataCache::Options& options) {
+  return create(allocator, nullptr, options);
+}
+
 // static
 AsyncDataCache* AsyncDataCache::getInstance() {
   return *getInstancePtr();
diff --git a/velox/common/caching/AsyncDataCache.h b/velox/common/caching/AsyncDataCache.h
index 0baf904de..a0eacb52f 100644
--- a/velox/common/caching/AsyncDataCache.h
+++ b/velox/common/caching/AsyncDataCache.h
@@ -734,17 +734,28 @@ class AsyncDataCache : public memory::Cache {
   AsyncDataCache(
       const Options& options,
       memory::MemoryAllocator* allocator,
-      std::unique_ptr<SsdCache> ssdCache = nullptr);
+      std::unique_ptr<SsdCache> ssdCache);
+
+  AsyncDataCache(
+      const Options& options,
+      memory::MemoryAllocator* allocator);
 
   AsyncDataCache(
       memory::MemoryAllocator* allocator,
-      std::unique_ptr<SsdCache> ssdCache = nullptr);
+      std::unique_ptr<SsdCache> ssdCache);
+
+  AsyncDataCache(
+      memory::MemoryAllocator* allocator);
 
   ~AsyncDataCache() override;
 
   static std::shared_ptr<AsyncDataCache> create(
       memory::MemoryAllocator* allocator,
-      std::unique_ptr<SsdCache> ssdCache = nullptr,
+      std::unique_ptr<SsdCache> ssdCache,
+      const AsyncDataCache::Options& = {});
+
+  static std::shared_ptr<AsyncDataCache> create(
+      memory::MemoryAllocator* allocator,
       const AsyncDataCache::Options& = {});
 
   static AsyncDataCache* getInstance();
diff --git a/velox/common/process/ThreadDebugInfo.cpp b/velox/common/process/ThreadDebugInfo.cpp
index ae681a2dc..35ebaf485 100644
--- a/velox/common/process/ThreadDebugInfo.cpp
+++ b/velox/common/process/ThreadDebugInfo.cpp
@@ -18,6 +18,7 @@
 
 #include <folly/experimental/symbolizer/SignalHandler.h>
 #include <glog/logging.h>
+#include <unistd.h>
 
 namespace facebook::velox::process {
 thread_local const ThreadDebugInfo* threadDebugInfo = nullptr;
diff --git a/velox/dwio/common/CacheInputStream.cpp b/velox/dwio/common/CacheInputStream.cpp
index 99f09c86c..cbf1f6ecf 100644
--- a/velox/dwio/common/CacheInputStream.cpp
+++ b/velox/dwio/common/CacheInputStream.cpp
@@ -142,8 +142,8 @@ bool CacheInputStream::SkipInt64(int64_t count) {
   return false;
 }
 
-google::protobuf::int64 CacheInputStream::ByteCount() const {
-  return static_cast<google::protobuf::int64>(position_);
+int64_t CacheInputStream::ByteCount() const {
+  return static_cast<int64_t>(position_);
 }
 
 void CacheInputStream::seekToPosition(PositionProvider& seekPosition) {
diff --git a/velox/dwio/common/CacheInputStream.h b/velox/dwio/common/CacheInputStream.h
index 195bdbdd1..1e1dab8d4 100644
--- a/velox/dwio/common/CacheInputStream.h
+++ b/velox/dwio/common/CacheInputStream.h
@@ -51,7 +51,7 @@ class CacheInputStream : public SeekableInputStream {
   bool Next(const void** data, int* size) override;
   void BackUp(int count) override;
   bool SkipInt64(int64_t count) override;
-  google::protobuf::int64 ByteCount() const override;
+  int64_t ByteCount() const override;
   void seekToPosition(PositionProvider& position) override;
   std::string getName() const override;
   size_t positionSize() const override;
diff --git a/velox/dwio/common/DirectInputStream.cpp b/velox/dwio/common/DirectInputStream.cpp
index 68173b40f..884076885 100644
--- a/velox/dwio/common/DirectInputStream.cpp
+++ b/velox/dwio/common/DirectInputStream.cpp
@@ -91,8 +91,8 @@ bool DirectInputStream::SkipInt64(int64_t count) {
   return false;
 }
 
-google::protobuf::int64 DirectInputStream::ByteCount() const {
-  return static_cast<google::protobuf::int64>(offsetInRegion_);
+int64_t DirectInputStream::ByteCount() const {
+  return static_cast<int64_t>(offsetInRegion_);
 }
 
 void DirectInputStream::seekToPosition(PositionProvider& seekPosition) {
diff --git a/velox/dwio/common/DirectInputStream.h b/velox/dwio/common/DirectInputStream.h
index 3d75b4459..45fb465f3 100644
--- a/velox/dwio/common/DirectInputStream.h
+++ b/velox/dwio/common/DirectInputStream.h
@@ -44,7 +44,7 @@ class DirectInputStream : public SeekableInputStream {
   bool Next(const void** data, int* size) override;
   void BackUp(int count) override;
   bool SkipInt64(int64_t count) override;
-  google::protobuf::int64 ByteCount() const override;
+  int64_t ByteCount() const override;
 
   void seekToPosition(PositionProvider& position) override;
   std::string getName() const override;
diff --git a/velox/dwio/common/OutputStream.h b/velox/dwio/common/OutputStream.h
index 9c93df048..d106cd4c9 100644
--- a/velox/dwio/common/OutputStream.h
+++ b/velox/dwio/common/OutputStream.h
@@ -47,8 +47,8 @@ class BufferedOutputStream : public google::protobuf::io::ZeroCopyOutputStream {
 
   void BackUp(int32_t count) override;
 
-  google::protobuf::int64 ByteCount() const override {
-    return static_cast<google::protobuf::int64>(size());
+  int64_t ByteCount() const override {
+    return static_cast<int64_t>(size());
   }
 
   bool WriteAliasedRaw(const void* /* unused */, int32_t /* unused */)
diff --git a/velox/dwio/common/SeekableInputStream.cpp b/velox/dwio/common/SeekableInputStream.cpp
index 2f4615516..7a16f838c 100644
--- a/velox/dwio/common/SeekableInputStream.cpp
+++ b/velox/dwio/common/SeekableInputStream.cpp
@@ -152,19 +152,20 @@ void SeekableArrayInputStream::BackUp(int32_t count) {
 bool SeekableArrayInputStream::SkipInt64(int64_t count) {
   loadIfAvailable();
 
-  if (count >= 0) {
-    const uint64_t unsignedCount = static_cast<uint64_t>(count);
-    if (unsignedCount + position_ <= length_) {
-      position_ += unsignedCount;
-      return true;
-    }
+  if (count < 0) {
+    return false;
+  }
+  const uint64_t unsignedCount = static_cast<uint64_t>(count);
+  if (unsignedCount > length_ - position_) {
     position_ = length_;
+    return false;
   }
-  return false;
+  position_ += unsignedCount;
+  return true;
 }
 
-google::protobuf::int64 SeekableArrayInputStream::ByteCount() const {
-  return static_cast<google::protobuf::int64>(position_);
+int64_t SeekableArrayInputStream::ByteCount() const {
+  return static_cast<int64_t>(position_);
 }
 
 void SeekableArrayInputStream::seekToPosition(PositionProvider& position) {
@@ -241,8 +242,8 @@ bool SeekableFileInputStream::SkipInt64(int64_t signedCount) {
   return position_ < length_;
 }
 
-google::protobuf::int64 SeekableFileInputStream::ByteCount() const {
-  return static_cast<google::protobuf::int64>(position_);
+int64_t SeekableFileInputStream::ByteCount() const {
+  return static_cast<int64_t>(position_);
 }
 
 void SeekableFileInputStream::seekToPosition(PositionProvider& location) {
diff --git a/velox/dwio/common/SeekableInputStream.h b/velox/dwio/common/SeekableInputStream.h
index c53347a62..f4e330085 100644
--- a/velox/dwio/common/SeekableInputStream.h
+++ b/velox/dwio/common/SeekableInputStream.h
@@ -79,7 +79,7 @@ class SeekableArrayInputStream : public SeekableInputStream {
   virtual bool Next(const void** data, int32_t* size) override;
   virtual void BackUp(int32_t count) override;
   virtual bool SkipInt64(int64_t count) override;
-  virtual google::protobuf::int64 ByteCount() const override;
+  virtual int64_t ByteCount() const override;
   virtual void seekToPosition(PositionProvider& position) override;
   virtual std::string getName() const override;
   virtual size_t positionSize() const override;
@@ -120,7 +120,7 @@ class SeekableFileInputStream : public SeekableInputStream {
   virtual bool Next(const void** data, int32_t* size) override;
   virtual void BackUp(int32_t count) override;
   virtual bool SkipInt64(int64_t count) override;
-  virtual google::protobuf::int64 ByteCount() const override;
+  virtual int64_t ByteCount() const override;
   virtual void seekToPosition(PositionProvider& position) override;
   virtual std::string getName() const override;
   virtual size_t positionSize() const override;
diff --git a/velox/dwio/common/compression/PagedInputStream.h b/velox/dwio/common/compression/PagedInputStream.h
index 15b1acd63..39d48cbb6 100644
--- a/velox/dwio/common/compression/PagedInputStream.h
+++ b/velox/dwio/common/compression/PagedInputStream.h
@@ -56,7 +56,7 @@ class PagedInputStream : public dwio::common::SeekableInputStream {
   // NOTE: This always returns true.
   bool SkipInt64(int64_t count) override;
 
-  google::protobuf::int64 ByteCount() const override {
+  int64_t ByteCount() const override {
     return bytesReturned_ + pendingSkip_;
   }
 
diff --git a/velox/dwio/dwrf/test/TestDecompression.cpp b/velox/dwio/dwrf/test/TestDecompression.cpp
index dcc315ad5..049c7a682 100644
--- a/velox/dwio/dwrf/test/TestDecompression.cpp
+++ b/velox/dwio/dwrf/test/TestDecompression.cpp
@@ -1065,7 +1065,7 @@ class TestingSeekableInputStream : public SeekableInputStream {
     return true;
   }
 
-  google::protobuf::int64 ByteCount() const override {
+  int64_t ByteCount() const override {
     return position_;
   }
 
diff --git a/velox/dwio/dwrf/writer/IndexBuilder.h b/velox/dwio/dwrf/writer/IndexBuilder.h
index 44bd15833..daa358602 100644
--- a/velox/dwio/dwrf/writer/IndexBuilder.h
+++ b/velox/dwio/dwrf/writer/IndexBuilder.h
@@ -41,9 +41,9 @@ class IndexBuilder : public PositionRecorder {
       : out_{std::move(out)},
         arena_(std::make_unique<google::protobuf::Arena>()) {
     auto rowIndex =
-        google::protobuf::Arena::CreateMessage<proto::RowIndex>(arena_.get());
+        google::protobuf::Arena::Create<proto::RowIndex>(arena_.get());
     auto rowIndexEntry =
-        google::protobuf::Arena::CreateMessage<proto::RowIndexEntry>(
+        google::protobuf::Arena::Create<proto::RowIndexEntry>(
             arena_.get());
 
     index_ = std::make_unique<RowIndexWriteWrapper>(rowIndex);
diff --git a/velox/dwio/dwrf/writer/LayoutPlanner.cpp b/velox/dwio/dwrf/writer/LayoutPlanner.cpp
index 07ce6fca3..15fe8b6e7 100644
--- a/velox/dwio/dwrf/writer/LayoutPlanner.cpp
+++ b/velox/dwio/dwrf/writer/LayoutPlanner.cpp
@@ -129,7 +129,7 @@ EncodingManager::EncodingManager(
       arena_{std::make_unique<google::protobuf::Arena>()} {
   initEncryptionGroups();
   auto dwrfStripeFooter =
-      google::protobuf::Arena::CreateMessage<proto::StripeFooter>(arena_.get());
+      google::protobuf::Arena::Create<proto::StripeFooter>(arena_.get());
   footer_ = std::make_unique<StripeFooterWriteWrapper>(dwrfStripeFooter);
 }
 
diff --git a/velox/dwio/dwrf/writer/StatisticsBuilder.cpp b/velox/dwio/dwrf/writer/StatisticsBuilder.cpp
index 779f73d25..23b172e32 100644
--- a/velox/dwio/dwrf/writer/StatisticsBuilder.cpp
+++ b/velox/dwio/dwrf/writer/StatisticsBuilder.cpp
@@ -119,7 +119,7 @@ void StatisticsBuilder::toProto(ColumnStatisticsWriteWrapper& stats) const {
 std::unique_ptr<dwio::common::ColumnStatistics> StatisticsBuilder::build()
     const {
   auto columnStatistics =
-      google::protobuf::Arena::CreateMessage<proto::ColumnStatistics>(
+      google::protobuf::Arena::Create<proto::ColumnStatistics>(
           arena_.get());
   auto stats = ColumnStatisticsWriteWrapper(columnStatistics);
   toProto(stats);
diff --git a/velox/dwio/dwrf/writer/WriterBase.cpp b/velox/dwio/dwrf/writer/WriterBase.cpp
index 69534a53b..fab5f91eb 100644
--- a/velox/dwio/dwrf/writer/WriterBase.cpp
+++ b/velox/dwio/dwrf/writer/WriterBase.cpp
@@ -59,7 +59,7 @@ void WriterBase::writeFooter(const Type& type) {
   // write postscript
   pos = writerSink_->size();
   auto dwrfPostScript =
-      google::protobuf::Arena::CreateMessage<proto::PostScript>(arena_.get());
+      google::protobuf::Arena::Create<proto::PostScript>(arena_.get());
   std::unique_ptr<PostScriptWriteWrapper> ps =
       std::make_unique<PostScriptWriteWrapper>(dwrfPostScript);
   ps->setWriterVersion(writerVersion);
diff --git a/velox/dwio/dwrf/writer/WriterBase.h b/velox/dwio/dwrf/writer/WriterBase.h
index 53bf008da..ad184717c 100644
--- a/velox/dwio/dwrf/writer/WriterBase.h
+++ b/velox/dwio/dwrf/writer/WriterBase.h
@@ -90,7 +90,7 @@ class WriterBase {
         context_->getMemoryPool(MemoryUsageCategory::OUTPUT_STREAM),
         context_->getConfigs());
     auto dwrfFooter_ =
-        google::protobuf::Arena::CreateMessage<proto::Footer>(arena_.get());
+        google::protobuf::Arena::Create<proto::Footer>(arena_.get());
     footer_ = std::make_unique<FooterWriteWrapper>(dwrfFooter_);
   }
 
diff --git a/velox/dwio/parquet/common/BitPacking.h b/velox/dwio/parquet/common/BitPacking.h
new file mode 100644
index 000000000..8eef9d15a
--- /dev/null
+++ b/velox/dwio/parquet/common/BitPacking.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/bpacking.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include "arrow/util/visibility.h"
+
+#include <stdint.h>
+
+namespace arrow::internal {
+
+ARROW_EXPORT
+int unpack32(const uint32_t* in, uint32_t* out, int batch_size, int num_bits);
+ARROW_EXPORT
+int unpack64(const uint8_t* in, uint64_t* out, int batch_size, int num_bits);
+
+} // namespace arrow::internal
diff --git a/velox/dwio/parquet/common/BitStreamUtilsInternal.h b/velox/dwio/parquet/common/BitStreamUtilsInternal.h
index a49cea663..001e3b3a0 100644
--- a/velox/dwio/parquet/common/BitStreamUtilsInternal.h
+++ b/velox/dwio/parquet/common/BitStreamUtilsInternal.h
@@ -27,7 +27,8 @@
 #include "velox/common/base/Exceptions.h"
 
 #include "arrow/util/bit_util.h"
-#include "arrow/util/bpacking.h"
+#include "arrow/util/endian.h"
+#include "velox/dwio/parquet/common/BitPacking.h"
 
 namespace facebook::velox::parquet {
 
diff --git a/velox/dwio/parquet/common/Spaced.h b/velox/dwio/parquet/common/Spaced.h
new file mode 100644
index 000000000..3cc4340d2
--- /dev/null
+++ b/velox/dwio/parquet/common/Spaced.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/spaced.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include <cassert>
+#include <cstdint>
+#include <cstring>
+
+#include <arrow/util/bit_run_reader.h>
+
+namespace facebook::velox::parquet::arrow::util::internal {
+
+/// \brief Compress the buffer to spaced, excluding the null entries.
+///
+/// \param[in] src the source buffer
+/// \param[in] num_values the size of source buffer
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \param[out] output the output buffer spaced
+/// \return The size of spaced buffer.
+template <typename T>
+inline int SpacedCompress(
+    const T* src,
+    int num_values,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset,
+    T* output) {
+  int num_valid_values = 0;
+
+  ::arrow::internal::SetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    std::memcpy(
+        output + num_valid_values, src + run.position, run.length * sizeof(T));
+    num_valid_values += static_cast<int32_t>(run.length);
+  }
+
+  return num_valid_values;
+}
+
+/// \brief Relocate values in buffer into positions of non-null values as
+/// indicated by a validity bitmap.
+///
+/// \param[in, out] buffer the in-place buffer
+/// \param[in] num_values total size of buffer including null slots
+/// \param[in] null_count number of null slots
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \return The number of values expanded, including nulls.
+template <typename T>
+inline int SpacedExpand(
+    T* buffer,
+    int num_values,
+    int null_count,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset) {
+  // Point to end as we add the spacing from the back.
+  int idx_decode = num_values - null_count;
+
+  // Depending on the number of nulls, some of the value slots in buffer may
+  // be uninitialized, and this will cause valgrind warnings / potentially UB
+  std::memset(
+      static_cast<void*>(buffer + idx_decode), 0, null_count * sizeof(T));
+  if (idx_decode == 0) {
+    // All nulls, nothing more to do
+    return num_values;
+  }
+
+  ::arrow::internal::ReverseSetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    idx_decode -= static_cast<int32_t>(run.length);
+    assert(idx_decode >= 0);
+    std::memmove(
+        buffer + run.position, buffer + idx_decode, run.length * sizeof(T));
+  }
+
+  // Otherwise caller gave an incorrect null_count
+  assert(idx_decode == 0);
+  return num_values;
+}
+
+} // namespace facebook::velox::parquet::arrow::util::internal
diff --git a/velox/dwio/parquet/writer/arrow/Encoding.cpp b/velox/dwio/parquet/writer/arrow/Encoding.cpp
index f4a5990e5..77829fe68 100644
--- a/velox/dwio/parquet/writer/arrow/Encoding.cpp
+++ b/velox/dwio/parquet/writer/arrow/Encoding.cpp
@@ -164,7 +164,7 @@ class PlainEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -379,7 +379,7 @@ class PlainEncoder<BooleanType> : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -997,7 +997,7 @@ void ByteStreamSplitEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -2744,7 +2744,7 @@ void DeltaBitPackEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3116,7 +3116,7 @@ void DeltaLengthByteArrayEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3353,7 +3353,7 @@ class RleBooleanEncoder final : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -3565,7 +3565,7 @@ class DeltaByteArrayEncoder : public EncoderImpl,
         PARQUET_THROW_NOT_OK(buffer_->Resize(num_values * sizeof(T), false));
       }
       T* data = reinterpret_cast<T*>(buffer_->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
diff --git a/velox/dwio/parquet/writer/arrow/Encoding.h b/velox/dwio/parquet/writer/arrow/Encoding.h
index b57ee2b68..0840e9e88 100644
--- a/velox/dwio/parquet/writer/arrow/Encoding.h
+++ b/velox/dwio/parquet/writer/arrow/Encoding.h
@@ -23,7 +23,7 @@
 #include <memory>
 #include <vector>
 
-#include "arrow/util/spaced.h"
+#include "velox/dwio/parquet/writer/arrow/util/Spaced.h"
 
 #include "velox/dwio/parquet/writer/arrow/Exception.h"
 #include "velox/dwio/parquet/writer/arrow/Platform.h"
@@ -307,7 +307,7 @@ class TypedDecoder : virtual public Decoder {
             "Number of values / definition_levels read did not match");
       }
 
-      return ::arrow::util::internal::SpacedExpand<T>(
+      return util::internal::SpacedExpand<T>(
           buffer, num_values, null_count, valid_bits, valid_bits_offset);
     } else {
       return Decode(buffer, num_values);
diff --git a/velox/dwio/parquet/writer/arrow/Exception.h b/velox/dwio/parquet/writer/arrow/Exception.h
index b71cfc926..7bf4e03ae 100644
--- a/velox/dwio/parquet/writer/arrow/Exception.h
+++ b/velox/dwio/parquet/writer/arrow/Exception.h
@@ -23,8 +23,13 @@
 #include <string>
 #include <utility>
 
+#include "arrow/config.h"
 #include "arrow/type_fwd.h"
+#if ARROW_VERSION_MAJOR >= 21
+#include "arrow/util/string_util.h"
+#else
 #include "arrow/util/string_builder.h"
+#endif
 #include "velox/dwio/parquet/writer/arrow/Platform.h"
 
 // PARQUET-1085
@@ -60,6 +65,22 @@
 
 // Arrow Status to Parquet exception
 
+#if ARROW_VERSION_MAJOR >= 21
+#define PARQUET_IGNORE_NOT_OK(s) \
+  do {                           \
+    ::arrow::Status _s = ::arrow::ToStatus(s); \
+    ARROW_UNUSED(_s);            \
+  } while (0)
+
+#define PARQUET_THROW_NOT_OK(s)                                            \
+  do {                                                                     \
+    ::arrow::Status _s = ::arrow::ToStatus(s);                             \
+    if (!_s.ok()) {                                                        \
+      throw ::facebook::velox::parquet::arrow::ParquetStatusException(     \
+          std::move(_s));                                                  \
+    }                                                                      \
+  } while (0)
+#else
 #define PARQUET_IGNORE_NOT_OK(s)                                \
   do {                                                          \
     ::arrow::Status _s = ::arrow::internal::GenericToStatus(s); \
@@ -74,6 +95,7 @@
           std::move(_s));                                              \
     }                                                                  \
   } while (0)
+#endif
 
 #define PARQUET_ASSIGN_OR_THROW_IMPL(status_name, lhs, rexpr) \
   auto status_name = (rexpr);                                 \
@@ -102,7 +124,14 @@ class ParquetException : public std::exception {
 
   template <typename... Args>
   explicit ParquetException(Args&&... args)
-      : msg_(::arrow::util::StringBuilder(std::forward<Args>(args)...)) {}
+      : msg_(
+#if ARROW_VERSION_MAJOR >= 21
+          ::arrow::internal::JoinToString(std::forward<Args>(args)...)
+#else
+          ::arrow::util::StringBuilder(std::forward<Args>(args)...)
+#endif
+      ) {
+  }
 
   explicit ParquetException(std::string msg) : msg_(std::move(msg)) {}
 
diff --git a/velox/dwio/parquet/writer/arrow/Writer.cpp b/velox/dwio/parquet/writer/arrow/Writer.cpp
index f3a101a02..8ed8dbf4a 100644
--- a/velox/dwio/parquet/writer/arrow/Writer.cpp
+++ b/velox/dwio/parquet/writer/arrow/Writer.cpp
@@ -419,16 +419,22 @@ class FileWriterImpl : public FileWriter {
 
     if (table.num_rows() == 0) {
       // Append a row group with 0 rows
-      RETURN_NOT_OK_ELSE(WriteRowGroup(0, 0), PARQUET_IGNORE_NOT_OK(Close()));
+      auto s = WriteRowGroup(0, 0);
+      if (!s.ok()) {
+        PARQUET_IGNORE_NOT_OK(Close());
+        return s;
+      }
       return Status::OK();
     }
 
     for (int chunk = 0; chunk * chunk_size < table.num_rows(); chunk++) {
       int64_t offset = chunk * chunk_size;
-      RETURN_NOT_OK_ELSE(
-          WriteRowGroup(
-              offset, std::min(chunk_size, table.num_rows() - offset)),
-          PARQUET_IGNORE_NOT_OK(Close()));
+      auto s = WriteRowGroup(
+          offset, std::min(chunk_size, table.num_rows() - offset));
+      if (!s.ok()) {
+        PARQUET_IGNORE_NOT_OK(Close());
+        return s;
+      }
     }
     return Status::OK();
   }
diff --git a/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp b/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp
index cb9f85196..8a5e63732 100644
--- a/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp
+++ b/velox/dwio/parquet/writer/arrow/tests/ColumnWriterTest.cpp
@@ -962,7 +962,8 @@ TEST(TestColumnWriter, RepeatedListsUpdateSpacedBug) {
   std::shared_ptr<Buffer> valid_bits;
   ASSERT_OK_AND_ASSIGN(
       valid_bits,
-      ::arrow::internal::BytesToBits({1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1}));
+      ::arrow::internal::BytesToBits(
+          std::vector<uint8_t>{1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1}));
 
   // valgrind will warn about out of bounds access into def_levels_data
   typed_writer->WriteBatchSpaced(
diff --git a/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp b/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp
index 47d501aef..5bd0f6129 100644
--- a/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp
+++ b/velox/dwio/parquet/writer/arrow/tests/EncodingTest.cpp
@@ -138,7 +138,7 @@ class PlainEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -359,7 +359,7 @@ class PlainEncoder<BooleanType> : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
@@ -1040,7 +1040,7 @@ void ByteStreamSplitEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -2712,7 +2712,7 @@ void DeltaBitPackEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3079,7 +3079,7 @@ void DeltaLengthByteArrayEncoder<DType>::PutSpaced(
         auto buffer,
         ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
     T* data = reinterpret_cast<T*>(buffer->mutable_data());
-    int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+    int num_valid_values = util::internal::SpacedCompress<T>(
         src, num_values, valid_bits, valid_bits_offset, data);
     Put(data, num_valid_values);
   } else {
@@ -3316,7 +3316,7 @@ class RleBooleanEncoder final : public EncoderImpl,
           auto buffer,
           ::arrow::AllocateBuffer(num_values * sizeof(T), this->memory_pool()));
       T* data = reinterpret_cast<T*>(buffer->mutable_data());
-      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(
+      int num_valid_values = util::internal::SpacedCompress<T>(
           src, num_values, valid_bits, valid_bits_offset, data);
       Put(data, num_valid_values);
     } else {
diff --git a/velox/dwio/parquet/writer/arrow/util/Spaced.h b/velox/dwio/parquet/writer/arrow/util/Spaced.h
new file mode 100644
index 000000000..3cc4340d2
--- /dev/null
+++ b/velox/dwio/parquet/writer/arrow/util/Spaced.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Adapted from Apache Arrow:
+// https://github.com/apache/arrow/blob/apache-arrow-15.0.0/cpp/src/arrow/util/spaced.h
+// Copyright 2016-2024 The Apache Software Foundation
+
+#pragma once
+
+#include <cassert>
+#include <cstdint>
+#include <cstring>
+
+#include <arrow/util/bit_run_reader.h>
+
+namespace facebook::velox::parquet::arrow::util::internal {
+
+/// \brief Compress the buffer to spaced, excluding the null entries.
+///
+/// \param[in] src the source buffer
+/// \param[in] num_values the size of source buffer
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \param[out] output the output buffer spaced
+/// \return The size of spaced buffer.
+template <typename T>
+inline int SpacedCompress(
+    const T* src,
+    int num_values,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset,
+    T* output) {
+  int num_valid_values = 0;
+
+  ::arrow::internal::SetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    std::memcpy(
+        output + num_valid_values, src + run.position, run.length * sizeof(T));
+    num_valid_values += static_cast<int32_t>(run.length);
+  }
+
+  return num_valid_values;
+}
+
+/// \brief Relocate values in buffer into positions of non-null values as
+/// indicated by a validity bitmap.
+///
+/// \param[in, out] buffer the in-place buffer
+/// \param[in] num_values total size of buffer including null slots
+/// \param[in] null_count number of null slots
+/// \param[in] valid_bits bitmap data indicating position of valid slots
+/// \param[in] valid_bits_offset offset into valid_bits
+/// \return The number of values expanded, including nulls.
+template <typename T>
+inline int SpacedExpand(
+    T* buffer,
+    int num_values,
+    int null_count,
+    const uint8_t* valid_bits,
+    int64_t valid_bits_offset) {
+  // Point to end as we add the spacing from the back.
+  int idx_decode = num_values - null_count;
+
+  // Depending on the number of nulls, some of the value slots in buffer may
+  // be uninitialized, and this will cause valgrind warnings / potentially UB
+  std::memset(
+      static_cast<void*>(buffer + idx_decode), 0, null_count * sizeof(T));
+  if (idx_decode == 0) {
+    // All nulls, nothing more to do
+    return num_values;
+  }
+
+  ::arrow::internal::ReverseSetBitRunReader reader(
+      valid_bits, valid_bits_offset, num_values);
+  while (true) {
+    const auto run = reader.NextRun();
+    if (run.length == 0) {
+      break;
+    }
+    idx_decode -= static_cast<int32_t>(run.length);
+    assert(idx_decode >= 0);
+    std::memmove(
+        buffer + run.position, buffer + idx_decode, run.length * sizeof(T));
+  }
+
+  // Otherwise caller gave an incorrect null_count
+  assert(idx_decode == 0);
+  return num_values;
+}
+
+} // namespace facebook::velox::parquet::arrow::util::internal
diff --git a/velox/external/hdfs/ArrowHdfsInternal.cpp b/velox/external/hdfs/ArrowHdfsInternal.cpp
index dc22b64ce306eb7665509b099b196223e8d91116..5ecc3546c18dd090de3efeb1d30a6d6688441f1e 100644
GIT binary patch
delta 21
ccmex0k+ESC;|4zqHpieK|M2+Deimy409!8yy8r+H

delta 14
VcmZpe#Q19>;|4#A%^?<R1OP6^1<?Qi

diff --git a/velox/type/DecimalUtil.h b/velox/type/DecimalUtil.h
index 581c776f7..cd8161fa9 100644
--- a/velox/type/DecimalUtil.h
+++ b/velox/type/DecimalUtil.h
@@ -356,10 +356,46 @@ class DecimalUtil {
         *writePosition++ = '-';
         unscaledValue = -unscaledValue;
       }
-      auto [position, errorCode] = std::to_chars(
-          writePosition,
-          writePosition + maxSize,
-          unscaledValue / DecimalUtil::kPowersOfTen[scale]);
+      auto to_chars_wrapper = [&](auto v) {
+        using V = decltype(v);
+        if constexpr (sizeof(V) <= 8) {
+          return std::to_chars(writePosition, writePosition + maxSize, v);
+        } else {
+          if (v <= static_cast<V>(std::numeric_limits<uint64_t>::max())) {
+            return std::to_chars(
+                writePosition, writePosition + maxSize, static_cast<uint64_t>(v));
+          } else {
+            char buf[40];
+            char* end = buf + 40;
+            char* curr = end;
+            auto tmp = v;
+            constexpr uint64_t kChunk = 10000000000000000000ULL;
+            while (tmp > std::numeric_limits<uint64_t>::max()) {
+              uint64_t rem = static_cast<uint64_t>(tmp % kChunk);
+              tmp /= kChunk;
+              char chunkBuf[20];
+              auto res = std::to_chars(chunkBuf, chunkBuf + 20, rem);
+              int len = res.ptr - chunkBuf;
+              curr -= 19;
+              std::memset(curr, '0', 19 - len);
+              std::memcpy(curr + (19 - len), chunkBuf, len);
+            }
+            uint64_t last = static_cast<uint64_t>(tmp);
+            char chunkBuf[20];
+            auto res = std::to_chars(chunkBuf, chunkBuf + 20, last);
+            int len = res.ptr - chunkBuf;
+            curr -= len;
+            std::memcpy(curr, chunkBuf, len);
+            int totalLen = end - curr;
+            std::memcpy(writePosition, curr, totalLen);
+            writePosition += totalLen;
+            return std::to_chars_result{writePosition, std::errc()};
+          }
+        }
+      };
+
+      auto [position, errorCode] =
+          to_chars_wrapper(unscaledValue / DecimalUtil::kPowersOfTen[scale]);
       VELOX_DCHECK_EQ(
           errorCode,
           std::errc(),
@@ -375,8 +411,7 @@ class DecimalUtil {
         std::memset(writePosition, '0', numLeadingZeros);
         writePosition += numLeadingZeros;
         // Append remaining fraction digits.
-        auto result =
-            std::to_chars(writePosition, writePosition + maxSize, fraction);
+        auto result = to_chars_wrapper(fraction);
         VELOX_DCHECK_EQ(
             result.ec,
             std::errc(),
